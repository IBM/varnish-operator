# VarnishService

### Creating a `VarnishService` Resource

Once you've [installed the operator](installation.md), you can create a new type of resource - `VarnishService`.

As with any other Kubernetes resource, simply `kubectl apply -f <varnish-service>.yaml` to create a `VarnishService`.

Here's an example of a simple `VarnishService`:

```yaml
apiVersion: icm.ibm.com/v1alpha1
kind: VarnishService
metadata:
  labels:
    operator: varnish
  name: varnish-service-example
spec:
  vclConfigMap:
    name: vcl-config
    entrypointFile: default.vcl
  statefulSet:
    container:
      imagePullSecret: docker-reg-secret
  service:
    selector:
      app: nginx
    varnishPort:
      port: 8080
      targetPort: 80
    varnishExporterPort:
      port: 9131
``` 

Make sure you've [created the image pull secret](https://pages.github.ibm.com/TheWeatherCompany/icm-docs/managed-kubernetes/container-registry.html#pulling-an-image-in-kubernetes) required to pull images from the private container registry.
 
Once the `VarnishService` is created, you should see:

* a StatefulSet with the name `<varnish-service-name>-statefulset`. This is the Varnish cluster, and should have inherited everything under the `statefulSet` part of the spec.
* 2 services, one `<varnish-service-name>` and one `<varnish-service-name>-no-cache`. As is implied by the names, using `<varnish-service-name>` will act as the service configured under `.spec.service`, and will direct to Varnish before hitting the underlying deployment, while `<varnish-service-name>-no-cache` will target the underlying deployment directly, with no Varnish caching. `<varnish-service-name>` will have inherited everything under the `service` part of the spec, other than its `selector`, which will be redirected to the Varnish pods.
* A ConfigMap with VCL in it (either user-created, before running `kubectl apply -f <varnish-service>.yaml`, or generated by operator)
* A role/rolebinding/clusterrole/clusterrolebinding/serviceAccount combination to give the Varnish pods the ability to access necessary resources.
* If configured, a PodDisruptionBudget

See [VarnishService configuration section](varnish-service-configuration.md) for all available fields for configuration.

### VarnishService Status

The VarnishService keeps track of its current status as events occur in the system. This can be seen through the `Status` field, visible from `kubectl describe vs <your-varnishservice>`.

### Labels

The labels set for `VarnishService` are inherited by all dependent components (Service, StatefulSet, etc.).

Besides custom labels, the operator sets its own:

 * `varnish-owner` - name of the VarnishService a particular component belongs to
 * `varnish-component` - name of the component

The `varnish-component` could have the following values:

 * `varnishes` - Varnish pod
 * `cache-service` - Kubernetes Service exposing Varnish instances
 * `nocache-service` - Kubernetes Service exposing backends bypassing Varnish
 * `clusterrole` - The clusterrole defining the cluster level permissions for a particular `VarnishService`
 * `clusterrolebinding` - Binds the clusterrole to the serviceaccount used by a particular `VarnishService`
 * `role` - The role defining the namespaced permissions for a particular `VarnishService`
 * `rolebinding` - Binds the role to the serviceaccount used by a particular `VarnishService`
 * `vcl-file-configmap` - The ConfigMap that stores the VCL files
 * `headless-service` - A headless service that backs the StatefulSet
 * `poddisruptionbudget` - PodDisruptionBudget configuration for a particular `VarnishService`
 * `serviceaccount` - A serviceaccount used by the Varnish pods

### Updating a VarnishService Resource

Just as with any other Kubernetes resource, using `kubectl apply`, `kubectl patch`, or `kubectl replace` will all update the VarnishService appropriately. The operator will handle how that update propagates to its dependent resources. Conversely, trying to modify any of those dependent resources (StatefulSet, Services, Roles/Rolebindings, etc) will cause the operator to revert those changes, in the same way a Deployment does for its Pods. The only exception to this is the ConfigMap, the contents of which you [can and should modify](vcl-configuration.md), since that is the VCL used to run the Varnish Pods.

Some spec changes (like the image version or container config change) need a pod restart in order to be applied. As Varnish is an in-memory cache, it means cache data loss. To prevent accidental cache loss, by default, the update strategy is `OnDelete` which means the pods won't automatically get restarted. To update the pod you need to delete the pod manually, and it will come back with the new configuration. This behavior can be changed by setting the desired update strategy in the `.spec.statefulSet.updateStrategy` object. See [Varnish Service Configuration](varnish-service-configuration.md) section for more details.

### Deleting a VarnishService Resource

Simply calling `kubectl delete` on the `VarnishService` will recursively delete all dependent resources, so that is the only action you need to take. This includes a user-generated ConfigMap, as the VarnishService will take ownership of that ConfigMap after creation. Deleting any of the dependent resources will trigger the operator to recreate that resource, in the same way that deleting the Pod of a Deployment will trigger the recreation of that Pod.